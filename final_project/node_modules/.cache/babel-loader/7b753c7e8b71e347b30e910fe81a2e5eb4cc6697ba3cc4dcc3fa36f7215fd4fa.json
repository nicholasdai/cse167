{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { __rest } from \"tslib\";\nimport React, { useEffect, useImperativeHandle, useRef } from 'react';\nimport clsx from 'clsx';\nimport { getBaseProps } from '../internal/base-component';\nimport { useMergeRefs } from '../internal/hooks/use-merge-refs';\nimport { LiveRegionController } from './controller';\nimport styles from './styles.css.js';\nimport testUtilStyles from './test-classes/styles.css.js';\nexport default React.forwardRef(function InternalLiveRegion(_a, ref) {\n  var {\n      assertive = false,\n      hidden = false,\n      tagName: TagName = 'div',\n      delay,\n      sources,\n      children,\n      __internalRootRef,\n      className\n    } = _a,\n    restProps = __rest(_a, [\"assertive\", \"hidden\", \"tagName\", \"delay\", \"sources\", \"children\", \"__internalRootRef\", \"className\"]);\n  const baseProps = getBaseProps(restProps);\n  const childrenRef = useRef(null);\n  const mergedRef = useMergeRefs(childrenRef, __internalRootRef);\n  useEffect(() => {\n    // We have to do this because `inert` isn't properly supported until\n    // React 19 and this seems much more maintainable than version detection.\n    // `inert` is better than `hidden` because it also blocks pointer and\n    // focus events as well as hiding the contents from screen readers.\n    // https://github.com/facebook/react/issues/17157\n    if (childrenRef.current) {\n      childrenRef.current.inert = hidden;\n    }\n  }, [hidden]);\n  // Initialize the live region controller inside an effect. We have to do this\n  // because the controller depends on DOM elements, which aren't available on the\n  // server.\n  const liveRegionControllerRef = useRef();\n  useEffect(() => {\n    const liveRegionController = new LiveRegionController(assertive ? 'assertive' : 'polite');\n    liveRegionControllerRef.current = liveRegionController;\n    return () => {\n      liveRegionController.destroy();\n      liveRegionControllerRef.current = undefined;\n    };\n  }, [assertive]);\n  const getContent = () => {\n    if (sources) {\n      return getSourceContent(sources);\n    }\n    if (childrenRef.current) {\n      return extractTextContent(childrenRef.current);\n    }\n  };\n  // Call the controller on every render. The controller will deduplicate the\n  // message against the previous announcement internally.\n  useEffect(() => {\n    var _a;\n    (_a = liveRegionControllerRef.current) === null || _a === void 0 ? void 0 : _a.announce({\n      message: getContent(),\n      delay\n    });\n  });\n  useImperativeHandle(ref, () => ({\n    reannounce() {\n      var _a;\n      (_a = liveRegionControllerRef.current) === null || _a === void 0 ? void 0 : _a.announce({\n        message: getContent(),\n        delay,\n        forceReannounce: true\n      });\n    }\n  }));\n  return React.createElement(TagName, Object.assign({\n    ref: mergedRef\n  }, baseProps, {\n    className: clsx(styles.root, testUtilStyles.root, className),\n    hidden: hidden\n  }), children);\n});\nfunction extractTextContent(node) {\n  // We use the text content of the node as the announcement text.\n  // This only extracts text content from the node including all its children which is enough for now.\n  // To make it more powerful, it is possible to create a more sophisticated extractor with respect to\n  // ARIA properties to ignore aria-hidden nodes and read ARIA labels from the live content.\n  return (node.textContent || '').replace(/\\s+/g, ' ').trim();\n}\nfunction getSourceContent(source) {\n  return source.map(item => {\n    if (!item || typeof item === 'string') {\n      return item;\n    }\n    if (item.current) {\n      return extractTextContent(item.current);\n    }\n  }).filter(Boolean).join(' ');\n}","map":{"version":3,"names":["React","useEffect","useImperativeHandle","useRef","clsx","getBaseProps","useMergeRefs","LiveRegionController","styles","testUtilStyles","forwardRef","InternalLiveRegion","_a","ref","assertive","hidden","tagName","TagName","delay","sources","children","__internalRootRef","className","restProps","__rest","baseProps","childrenRef","mergedRef","current","inert","liveRegionControllerRef","liveRegionController","destroy","undefined","getContent","getSourceContent","extractTextContent","announce","message","reannounce","forceReannounce","createElement","Object","assign","root","node","textContent","replace","trim","source","map","item","filter","Boolean","join"],"sources":["C:\\Users\\nicky\\Documents\\GitHub\\cse167\\final_project\\node_modules\\src\\live-region\\internal.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport React, { useEffect, useImperativeHandle, useRef } from 'react';\nimport clsx from 'clsx';\n\nimport { getBaseProps } from '../internal/base-component';\nimport { InternalBaseComponentProps } from '../internal/hooks/use-base-component';\nimport { useMergeRefs } from '../internal/hooks/use-merge-refs';\nimport { LiveRegionController } from './controller';\nimport { LiveRegionProps } from './interfaces';\n\nimport styles from './styles.css.js';\nimport testUtilStyles from './test-classes/styles.css.js';\n\nexport interface InternalLiveRegionProps extends InternalBaseComponentProps, LiveRegionProps {\n  /**\n   * The delay between each announcement from this live region. You should\n   * leave this set to the default unless this live region is commonly\n   * interrupted by other actions (like text entry in text filtering).\n   */\n  delay?: number;\n\n  /**\n   * Use a list of strings and/or refs to existing elements for building the\n   * announcement text. If this property is set, `children` and `message` will\n   * be ignored.\n   */\n  sources?: ReadonlyArray<string | React.RefObject<HTMLElement> | undefined>;\n}\n\nexport interface InternalLiveRegionRef {\n  /**\n   * Force the live region to announce the message, even if it's the same as\n   * the previously announced message.\n   *\n   * This is useful when making status updates after a change (e.g. filtering)\n   * where the new message might be the same as the old one, but the announcement\n   * also serves to tell screen reader users that the action was performed.\n   */\n  reannounce(): void;\n}\n\nexport default React.forwardRef(function InternalLiveRegion(\n  {\n    assertive = false,\n    hidden = false,\n    tagName: TagName = 'div',\n    delay,\n    sources,\n    children,\n    __internalRootRef,\n    className,\n    ...restProps\n  }: InternalLiveRegionProps,\n  ref: React.Ref<InternalLiveRegionRef>\n) {\n  const baseProps = getBaseProps(restProps);\n  const childrenRef = useRef<HTMLSpanElement & HTMLDivElement>(null);\n  const mergedRef = useMergeRefs(childrenRef, __internalRootRef);\n\n  useEffect(() => {\n    // We have to do this because `inert` isn't properly supported until\n    // React 19 and this seems much more maintainable than version detection.\n    // `inert` is better than `hidden` because it also blocks pointer and\n    // focus events as well as hiding the contents from screen readers.\n    // https://github.com/facebook/react/issues/17157\n    if (childrenRef.current) {\n      childrenRef.current.inert = hidden;\n    }\n  }, [hidden]);\n\n  // Initialize the live region controller inside an effect. We have to do this\n  // because the controller depends on DOM elements, which aren't available on the\n  // server.\n  const liveRegionControllerRef = useRef<LiveRegionController | undefined>();\n  useEffect(() => {\n    const liveRegionController = new LiveRegionController(assertive ? 'assertive' : 'polite');\n    liveRegionControllerRef.current = liveRegionController;\n    return () => {\n      liveRegionController.destroy();\n      liveRegionControllerRef.current = undefined;\n    };\n  }, [assertive]);\n\n  const getContent = () => {\n    if (sources) {\n      return getSourceContent(sources);\n    }\n    if (childrenRef.current) {\n      return extractTextContent(childrenRef.current);\n    }\n  };\n\n  // Call the controller on every render. The controller will deduplicate the\n  // message against the previous announcement internally.\n  useEffect(() => {\n    liveRegionControllerRef.current?.announce({ message: getContent(), delay });\n  });\n\n  useImperativeHandle(ref, () => ({\n    reannounce() {\n      liveRegionControllerRef.current?.announce({ message: getContent(), delay, forceReannounce: true });\n    },\n  }));\n\n  return (\n    <TagName\n      ref={mergedRef}\n      {...baseProps}\n      className={clsx(styles.root, testUtilStyles.root, className)}\n      hidden={hidden}\n    >\n      {children}\n    </TagName>\n  );\n});\n\nfunction extractTextContent(node: HTMLElement): string {\n  // We use the text content of the node as the announcement text.\n  // This only extracts text content from the node including all its children which is enough for now.\n  // To make it more powerful, it is possible to create a more sophisticated extractor with respect to\n  // ARIA properties to ignore aria-hidden nodes and read ARIA labels from the live content.\n  return (node.textContent || '').replace(/\\s+/g, ' ').trim();\n}\n\nfunction getSourceContent(source: ReadonlyArray<string | React.RefObject<HTMLElement> | undefined>): string {\n  return source\n    .map(item => {\n      if (!item || typeof item === 'string') {\n        return item;\n      }\n      if (item.current) {\n        return extractTextContent(item.current);\n      }\n    })\n    .filter(Boolean)\n    .join(' ');\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}